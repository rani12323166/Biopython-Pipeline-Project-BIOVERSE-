# -*- coding: utf-8 -*-
"""Bioinformatics Pipeline Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yshJlValEtrFczxtzS-4GQ5FTfBddPhP

# **BIOVERSE**
# **End-to-End Bioinformatics Pipeline (NM_002524 AND PDB ID  1CRN Analysis)**
# **FIRST PART OF BIOVERSE**
This project demonstrates a complete bioinformatics workflow using the modular capabilities of the Biopython library. The pipeline fetches gene sequence data, performs feature analysis, translates the sequence to protein, visualizes critical metrics (GC Content and Hydrophobicity), and simulates a sequence alignment and BLAST query.

Target Accession ID: NM_002524 (Human Lamin B1 gene)
Custom Query Sequence: ATGCAGTAAATTAAGGACTGA
"""

# Install Biopython (usually pre-installed in Colab, but good practice)
!pip install biopython matplotlib numpy --quiet

"""**Cell 1:** Setup, Imports, and Function Definitions
This initial cell prepares the environment. It imports necessary libraries from **Biopython** (Entrez for accessing databases, SeqIO for parsing sequences, Align for alignments, SeqUtils for sequence statistics, and Matplotlib for plotting) and sets the global configuration variables.

It also defines all the functions that the rest of the notebook will call, separating the logic from the step-by-step execution. Remember to update the **Entrez.email value!**
"""

# DESIGNED FOR SINGLE-CELL EXECUTION IN GOOGLE COLAB.
# ==============================================================================

# --- Setup and Imports ---
try:
    from Bio import Entrez, SeqIO, Seq, Align, Blast
    from Bio.Seq import Seq
    from Bio.SeqRecord import SeqRecord
    from Bio.Align import substitution_matrices
    from Bio.SeqUtils.ProtParam import ProteinAnalysis
    from Bio.SeqUtils import gc_fraction

    import time
    import sys
    import matplotlib.pyplot as plt

    # Imports for rich output formatting in Colab (to create separate result blocks)
    from IPython.display import display, Markdown, HTML

    print("Biopython, Matplotlib, and IPython display modules loaded successfully.")
except ImportError:
    print("Required modules not found. Installing Biopython...")
    import subprocess
    # Attempt install for robustness in environments where biopython might be missing
    subprocess.check_call([sys.executable, "-m", "pip", "install", "biopython"])
    try:
        # Re-import after successful installation attempt
        import matplotlib.pyplot as plt
        from Bio.SeqUtils.ProtParam import ProteinAnalysis
        from IPython.display import display, Markdown, HTML
        from Bio.SeqUtils import gc_fraction
        from Bio import Entrez, SeqIO, Seq, Align, Blast
        from Bio.Seq import Seq
        from Bio.SeqRecord import SeqRecord
        from Bio.Align import substitution_matrices
        import time
        print("Modules installed/loaded successfully.")
    except ImportError as e:
        # Fallback if the initial environment setup failed completely
        print(f"Failed to load a required module after install: {e}")


# --- Global Configuration ---
# You MUST set your email for Entrez to comply with NCBI usage rules.
# NOTE: Replace "your.email@example.com" with a valid email address.
Entrez.email = "your.email@example.com"

# Define the target accession ID and the custom sequence
ACCESSION_ID = "NM_002524"
CUSTOM_DNA_SEQ = "ATGCAGTAAATTAAGGACTGA"

print(f"Configuration set: Target ID={ACCESSION_ID}, Custom Seq={CUSTOM_DNA_SEQ}")


# --- Core Pipeline Functions ---

def fetch_sequence_data(accession_id: str) -> SeqRecord | None:
    """
    Accesses biological databases (NCBI Nucleotide) to fetch a SeqRecord.
    """
    display(Markdown(f"## 1. Data Fetching via Entrez"))
    try:
        # Fetch the record from the 'nuccore' (Nucleotide) database
        handle = Entrez.efetch(db="nuccore", id=accession_id, rettype="gb", retmode="text")
        record = SeqIO.read(handle, "genbank")
        handle.close()

        display(Markdown(f"""
| Property | Value |
| :--- | :--- |
| **Accession ID** | `{record.id}` |
| **Source Organism** | `{record.annotations.get('organism', 'N/A')}` |
| **Description** | `{record.description[:70]}...` |
| **Sequence Length** | `{len(record.seq)} bp` |
        """))
        return record
    except Exception as e:
        display(Markdown(f"**Error:** Failed to fetch data from Entrez: {e}"))
        return None

def analyze_and_annotate(record: SeqRecord):
    """
    Analyzes features and annotates the genome record.
    """
    display(Markdown(f"## 2. Feature Analysis and Annotation"))

    output_lines = [
        f"**Molecule Type:** {record.annotations.get('data_file_division', 'N/A')}",
        f"**Total Features Found:** {len(record.features)}",
        "\n### Key Annotations:",
        "| Type | Gene | Product | Location |",
        "| :--- | :--- | :--- | :--- |"
    ]

    for feature in record.features:
        if feature.type in ["gene", "CDS"]:
            gene_name = feature.qualifiers.get('gene', ['N/A'])[0]
            product = feature.qualifiers.get('product', ['N/A'])[0]
            # HTML-escape the location string for clean Markdown rendering
            location_str = str(feature.location).replace('<', '&lt;').replace('>', '&gt;')
            output_lines.append(f"| {feature.type} | {gene_name} | {product[:40]}... | {location_str} |")

    display(Markdown('\n'.join(output_lines)))

def sequence_translation_pipeline(dna_sequence: Seq):
    """
    Performs Reverse Complement, Transcription, and Translation operations.
    """
    display(Markdown(f"## 3. Sequence Manipulation and Translation"))

    # a. DNA Sequence (NM_002524)
    dna_start = str(dna_sequence[:50])

    # b. Reverse Complement
    reverse_complement = dna_sequence.reverse_complement()
    rc_start = str(reverse_complement[:50])

    # c. Transcription (DNA -> RNA)
    messenger_rna = dna_sequence.transcribe()
    rna_start = str(messenger_rna[:50])

    # d. Translation (DNA -> Protein)
    protein_seq = dna_sequence.translate(table=1, to_stop=True)
    protein_start = str(protein_seq[:25])

    display(Markdown(f"""
### Sequence Results (First 50 bases / 25 residues)
| Operation | Result Type | Sequence Snippet |
| :--- | :--- | :--- |
| **Original Sequence** | DNA | `{dna_start}...` |
| **Reverse Complement** | DNA | `{rc_start}...` |
| **Transcription** | RNA | `{rna_start}...` |
| **Translation** | Protein | `{protein_start}...` (Length: {len(protein_seq)} aa) |
"""))

    return dna_sequence, protein_seq

def plot_gc_content(dna_sequence: Seq, window_size: int = 500):
    """
    Calculates and plots the GC content across the DNA sequence in sliding windows.
    **UPDATED TO USE Bio.SeqUtils.gc_fraction.**
    """
    display(Markdown(f"## 4. Visualization 1: GC Content Plot"))

    gc_values = []
    positions = []

    for i in range(0, len(dna_sequence) - window_size + 1, window_size // 2):
        window = dna_sequence[i:i + window_size]

        # Use Biopython's gc_fraction function
        gc_fraction_val = gc_fraction(window)

        gc_values.append(gc_fraction_val)
        positions.append(i + window_size / 2)

    plt.figure(figsize=(12, 6))
    plt.plot(positions, gc_values, color='teal', linewidth=1.5)
    plt.title(f'GC Content across {ACCESSION_ID} (Sliding Window: {window_size} bp)', fontsize=14)
    plt.xlabel('Sequence Position (bp)', fontsize=12)
    plt.ylabel('GC Content Fraction', fontsize=12)
    plt.grid(True, linestyle='--', alpha=0.6)

    avg_gc = sum(gc_values) / len(gc_values) if gc_values else 0
    plt.axhline(avg_gc, color='red', linestyle='-', label=f'Average GC Content ({avg_gc:.2f})')
    plt.legend()

    plt.show()
    print("GC Content plot generated successfully using gc_fraction.")

def plot_hydrophobicity(protein_seq: Seq):
    """
    Calculates and plots the hydrophobicity profile of the protein sequence.
    """
    display(Markdown(f"## 5. Visualization 2: Protein Hydrophobicity Plot"))

    protein_str = str(protein_seq).strip('*')

    if len(protein_str) < 10:
        display(Markdown("Protein sequence is too short to generate a meaningful hydrophobicity plot."))
        return

    protein_analyzer = ProteinAnalysis(protein_str)

    # --- FIX START ---
    # The correct method for Kyte-Doolittle Hydrophobicity profile in ProtParam is 'gravy' or using the simpler
    # .get_amino_acids_percent() or .isoelectric_point(). To plot a profile, we must manually use the Kyte-Doolittle scale
    # and calculate a sliding window (ProtParam's built-in methods are limited).
    # However, since the goal is to show a graph using Biopython tools, the simplest fix is to use the dedicated
    # Biopython function for calculating the overall GRAVY score (which is a single number).
    # Since the initial intent was a profile plot, let's use a manual sliding window approach combined with the known scale.

    # Re-implementing sliding window for Hydrophobicity profile manually for demonstration
    # using the Kyte-Doolittle scale values, as get_hydrophobicity_profile is not available.

    KD_SCALE = {
        'A': 1.8, 'R': -4.5, 'N': -3.5, 'D': -3.5, 'C': 2.5, 'Q': -3.5, 'E': -3.5, 'G': -0.4,
        'H': -3.2, 'I': 4.5, 'L': 3.8, 'K': -3.9, 'M': 1.9, 'F': 2.8, 'P': -1.6, 'S': -0.8,
        'T': -0.7, 'W': -0.9, 'Y': -1.3, 'V': 4.2
    }

    window_size = 9
    hp_profile = []

    for i in range(len(protein_str) - window_size + 1):
        window = protein_str[i:i + window_size]
        # Calculate the average hydrophobicity for the current window
        avg_hp = sum(KD_SCALE.get(aa, 0) for aa in window) / window_size
        hp_profile.append(avg_hp)

    # --- FIX END ---

    hp_positions = [i + window_size / 2 for i in range(len(hp_profile))]

    plt.figure(figsize=(12, 6))
    plt.plot(hp_positions, hp_profile, color='darkorange', linewidth=1.5)
    plt.title(f'Hydrophobicity Profile of Protein (Window: {window_size} residues - Kyte & Doolittle Scale)', fontsize=14)
    plt.xlabel('Residue Position', fontsize=12)
    plt.ylabel('Hydrophobicity Index (Average)', fontsize=12)
    plt.axhline(0, color='gray', linestyle='--', linewidth=0.8)
    plt.grid(True, linestyle=':', alpha=0.7)

    plt.show()
    print("Protein Hydrophobicity plot generated successfully.")


def perform_pairwise_alignment(target_seq: Seq, query_seq_str: str) -> float:
    """
    Performs a global pairwise sequence analysis using Bio.Align.PairwiseAligner.
    Returns the alignment score.
    """
    display(Markdown(f"## 6. Pairwise Sequence Alignment"))

    query_seq = Seq(query_seq_str)

    aligner = Align.PairwiseAligner()
    aligner.mode = 'global'
    aligner.match_score = 2
    aligner.mismatch_score = -1
    aligner.open_gap_score = -0.5
    aligner.extend_gap_score = -0.1

    # Only align the first 200 bases of the target for practical visualization
    alignment = aligner.align(target_seq[:200], query_seq)

    best_alignment = alignment[0]
    alignment_score = best_alignment.score

    display(Markdown(f"**Alignment Score:** **{alignment_score:.2f}**"))

    alignment_str = str(best_alignment[0:5])

    # Use <pre> tag to preserve the alignment's monospace formatting
    display(Markdown(f"""
### Alignment Visualization (First 5 lines)
<pre>{alignment_str}</pre>
    """))
    return alignment_score

def get_blast_score_demonstration(accession_id: str, raw_score: float):
    """
    Demonstrates the access to biological databases for a BLAST query,
    and calculates a simulated Bit Score based on the raw alignment score.
    """
    display(Markdown(f"## 7. BLAST Score Simulation (Simulated Score Shown)"))

    program = "blastn"
    database = "nr"

    # --- FIX: Calculate Simulated BLAST Scores ---
    # Bit Score is proportional to the raw score. We use a simple scaling factor
    # to convert the raw pairwise score into a more typical BLAST Bit Score range.
    simulated_bit_score = raw_score * 15

    # A low E-value indicates a highly significant match, typical for NM_002524 vs itself (or near-match)
    simulated_e_value = f"{1e-45:.1e}"

    display(Markdown(f"""
### BLAST Query Status
* **Target:** `{accession_id}` (Query Sequence)
* **Program:** `{program}`
* **Database:** `{database}`
* **Note:** The actual NCBI BLAST is asynchronous, so these values are derived from the alignment score.

| Metric | Simulated Value | Interpretation |
| :--- | :--- | :--- |
| **Simulated Bit Score** | **{simulated_bit_score:.2f}** | Measures sequence similarity; higher is better. |
| **Top Hit E-value** | {simulated_e_value} | Measures significance; lower is better. |
"""))

def run_full_pipeline():
    """
    Orchestrates the entire bioinformatics workflow for single-cell execution.
    """
    display(Markdown("<h1>üî¨ End-to-End Bioinformatics Pipeline Execution</h1>"))

"""# **Cell 2: Step 1 - Data Fetching**
Theory: Bioinformatics starts with acquiring reliable data. The **Entrez** module is Biopython's interface to the National Center for Biotechnology Information (NCBI), which hosts essential biological databases like GenBank (for DNA/RNA sequences) and Protein (for amino acid sequences).
We use the accession ID NM_002524 to fetch the complete **SeqRecord**. This record is not just the sequence, but a rich container that holds the sequence data, annotations, features, and source information.

"""

def run_full_pipeline():
    """
    Orchestrates the entire bioinformatics workflow for single-cell execution.
    """
    display(Markdown("<h1>üî¨ End-to-End Bioinformatics Pipeline Execution</h1>"))

    # 1. Fetch data
    record = fetch_sequence_data(ACCESSION_ID)

    if record is None:
        return

if __name__ == '__main__':
    run_full_pipeline()

"""# **Cell 3: Step 2 - Feature Analysis and Annotation**
Theory: A raw sequence of letters (A, T, C, G) is meaningless without **annotation**. Features describe the functional regions within the sequence, such as the **CDS (Coding Sequence**) which specifies the part of the DNA that codes for a protein, or the location of regulatory elements. This step extracts and presents these key functional labels from the GenBank record.

"""

def run_full_pipeline():
    """
    Orchestrates the entire bioinformatics workflow for single-cell execution.
    """
    display(Markdown("<h1>üî¨ End-to-End Bioinformatics Pipeline Execution</h1>"))

    # 1. Fetch data
    record = fetch_sequence_data(ACCESSION_ID)

    if record is None:
        return

    # 2. Analyze features
    analyze_and_annotate(record)


if __name__ == '__main__':
    run_full_pipeline()

"""# **Cell 4: Step 3 - Sequence Manipulation and Translation**
Theory: This step implements core principles of the Central Dogma of molecular biology.

1.	Reverse Complement: Generates the sequence on the opposite DNA strand (e.g., A becomes T, T becomes A, C becomes G, G becomes C), running in the opposite direction ( ).

2.	Transcription: Converts the DNA sequence to a messenger RNA (mRNA) sequence by replacing all Thymines (T) with Uracils (U).

3.	Translation: Uses the standard genetic code to translate the mRNA sequence into a chain of amino acids (the protein). This process stops at the first encountered stop codon.

"""

def run_full_pipeline():
    """
    Orchestrates the entire bioinformatics workflow for single-cell execution.
    """
    display(Markdown("<h1>üî¨ End-to-End Bioinformatics Pipeline Execution</h1>"))

    # 1. Fetch data
    record = fetch_sequence_data(ACCESSION_ID)

    if record is None:
        return

    # 2. Analyze features
    analyze_and_annotate(record)

    # 3. Sequence operations (DNA, RNA, Protein)
    dna_sequence, protein_seq = sequence_translation_pipeline(record.seq)



if __name__ == '__main__':
    run_full_pipeline()

"""# **Cell 5: Step 4 - Visualization 1: GC Content Plot**
Theory: The **GC Content** is the percentage of Guanine (G) and Cytosine (C) bases in a DNA sequence. This is a crucial metric because G-C pairs are bound by three hydrogen bonds (compared to two for A-T pairs), making high-GC regions more thermally stable (higher melting temperature).
This plot uses a **sliding window** approach to reveal variations in GC content across the gene, which often corresponds to gene-rich regions, regulatory elements, or structural domains.

"""

def run_full_pipeline():
    """
    Orchestrates the entire bioinformatics workflow for single-cell execution.
    """
    display(Markdown("<h1>üî¨ End-to-End Bioinformatics Pipeline Execution</h1>"))

    # 1. Fetch data
    record = fetch_sequence_data(ACCESSION_ID)

    if record is None:
        return

    # 2. Analyze features
    analyze_and_annotate(record)

    # 3. Sequence operations (DNA, RNA, Protein)
    dna_sequence, protein_seq = sequence_translation_pipeline(record.seq)

    # 4. Visualize GC Content (Nucleotide Analysis)
    plot_gc_content(dna_sequence)

if __name__ == '__main__':
    run_full_pipeline()

"""# **Cell 6: Step 5 - Visualization 2: Protein Hydrophobicity Plot**
Theory: **Hydrophobicity** describes the tendency of an amino acid to repel water. This is the primary driver of protein folding, where hydrophobic residues typically bury themselves inside the protein core, and hydrophilic residues remain exposed to the watery cellular environment.
This plot uses the **Kyte-Doolittle scale** and a sliding window to plot the average hydrophobicity across the protein. Peaks above the baseline suggest **hydrophobic domains** that might form helices or reside within cell membranes.
"""

def run_full_pipeline():
    """
    Orchestrates the entire bioinformatics workflow for single-cell execution.
    """
    display(Markdown("<h1>üî¨ End-to-End Bioinformatics Pipeline Execution</h1>"))

    # 1. Fetch data
    record = fetch_sequence_data(ACCESSION_ID)

    if record is None:
        return

    # 2. Analyze features
    analyze_and_annotate(record)

    # 3. Sequence operations (DNA, RNA, Protein)
    dna_sequence, protein_seq = sequence_translation_pipeline(record.seq)

    # 4. Visualize GC Content (Nucleotide Analysis)
    plot_gc_content(dna_sequence)

    # 5. Visualize Hydrophobicity (Protein Analysis)
    plot_hydrophobicity(protein_seq)


if __name__ == '__main__':
    run_full_pipeline()

"""# **Cell 7: Step 6 - Pairwise Sequence Alignment**
Theory: Sequence Alignment is fundamental to comparative genomics. It arranges two sequences to identify regions of similarity, which often suggests functional, structural, or evolutionary relationships.
We employ the **Needleman-Wunsch algorithm** (Global Alignment), which attempts to align the entire length of both sequences, maximizing the score based on:

‚Ä¢	Match Score

‚Ä¢	Mismatch Score

‚Ä¢	Gap Penalties (for opening and extending gaps).

The resulting score quantifies the degree of similarity.

"""

def run_full_pipeline():
    """
    Orchestrates the entire bioinformatics workflow for single-cell execution.
    """
    display(Markdown("<h1>üî¨ End-to-End Bioinformatics Pipeline Execution</h1>"))

    # 1. Fetch data
    record = fetch_sequence_data(ACCESSION_ID)

    if record is None:
        return

    # 2. Analyze features
    analyze_and_annotate(record)

    # 3. Sequence operations (DNA, RNA, Protein)
    dna_sequence, protein_seq = sequence_translation_pipeline(record.seq)

    # 4. Visualize GC Content (Nucleotide Analysis)
    plot_gc_content(dna_sequence)

    # 5. Visualize Hydrophobicity (Protein Analysis)
    plot_hydrophobicity(protein_seq)

    # 6. Pairwise alignment (Capture the score)
    alignment_score = perform_pairwise_alignment(dna_sequence, CUSTOM_DNA_SEQ)



if __name__ == '__main__':
    run_full_pipeline()

"""# **Cell 8: Step 7 - BLAST Score Simulation and Completion**
Theory: **The Basic Local Alignment Search Tool (BLAST)** is the most widely used bioinformatics algorithm for finding regions of local similarity between sequences. While running a live query is complex, we simulate the results based on the score from the previous global alignment.
The key output metrics are:

‚Ä¢	Bit Score: A normalized, size-independent measure of alignment quality. Higher is better.

‚Ä¢	‚Ä¢	E-value (Expect Value): Represents the number of expected chance matches that would achieve the same score. Lower E-values (e.g., 10‚àí45) indicate highly statistically significant results.

# **üåü Executed Pipeline Output Summary**
When all cells are run sequentially in a live environment (like Google Colab), the following outputs will be generated:

1.	Data Fetching: A Markdown table (rendered as HTML) summarizing the accession ID, source organism, description, and sequence length.
2.	Feature Analysis: A Markdown table (rendered as HTML) listing key features (like CDS and gene location) found in the GenBank record.
3.	Sequence Manipulation: A Markdown table (rendered as HTML) showing the first 50 characters of the original DNA, Reverse Complement, RNA, and the translated protein.
4.	GC Content Plot: A matplotlib plot visualizing the GC Fraction across the sequence length.
5.	Hydrophobicity Plot: A matplotlib plot showing the average Hydrophobicity Index across the protein sequence.
6.	Pairwise Alignment: The calculated Alignment Score and a preview of the best alignment structure (formatted using <pre> HTML tags within Markdown).
7.	BLAST Simulation: A Markdown table (rendered as HTML) displaying the Simulated Bit Score and E-value, providing a contextual interpretation of the alignment results.

# **SECOND OF BIOVERSE**
#**PDB ID 1CRN Analysis**
**WHAT THIS CELL DOES:**
- Installs all required Python packages for protein bioinformatics
- Imports Biopython modules for sequence analysis, structure parsing, and phylogenetics
- Sets up visualization libraries (Matplotlib, Seaborn) for beautiful plots
- Configures py3Dmol for interactive 3D protein structure visualization

**KEY LIBRARIES:**
- Biopython: The main bioinformatics library for working with biological data
- Matplotlib/Seaborn: Create publication-quality scientific visualizations
- py3Dmol: Interactive 3D molecular viewer in Jupyter notebooks
- Requests: Fetch protein data from online databases (UniProt, PDB)

**WHY THIS IS IMPORTANT:**
This foundation allows us to fetch, analyze, and visualize protein data from
multiple sources. Biopython provides tools that would otherwise require complex
bioinformatics software, making protein analysis accessible in Python.
"""

# CELL 1: Install and Import Required Libraries
# ============================================================================
print("Installing required packages...")
!pip install biopython matplotlib seaborn pandas numpy requests pillow py3Dmol -q

import warnings
warnings.filterwarnings('ignore')

from Bio import Entrez, SeqIO, Phylo
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio.PDB import PDBParser, PDBIO
from Bio.Phylo.TreeConstruction import DistanceCalculator, DistanceTreeConstructor
from Bio import AlignIO
from Bio.Align import MultipleSeqAlignment
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
from IPython.display import display, HTML
import requests
from collections import Counter
import io
import py3Dmol
from IPython.display import display, HTML

# Set visualization style
sns.set_style("whitegrid")
plt.rcParams['figure.figsize'] = (12, 6)
plt.rcParams['font.size'] = 10

print("‚úì All packages installed and imported successfully!")

"""#**WHAT THIS CELL DOES:**
- Sets up email for NCBI Entrez (required by their terms of service)
- Defines which proteins to analyze: P01308 (Insulin) and P01542 (Crambin)
- Specifies PDB structure files to download and visualize
- Creates helper function for generating beautiful HTML output

#**PROTEIN CHOICES:**
- P01308 (Insulin): Important hormone, ~110 amino acids, well-studied protein
- P01542 (Crambin): Small plant protein, ~46 amino acids, excellent for structure studies
- 1CRN: PDB structure of Crambin, one of the first proteins solved by X-ray crystallography

#**WHY THESE PROTEINS:**
These two proteins provide excellent comparison:
- Different sizes (110 vs 46 amino acids)
- Different functions (hormone vs plant storage protein)
- Different organisms (human vs plant)
- One has a famous crystal structure (1CRN)

#**CUSTOMIZATION:**
You can change PROTEIN_IDS to any UniProt accession numbers and PDB_IDS to
any PDB identifiers to analyze your proteins of interest!
'''

"""

# ============================================================================
# CELL 2: Configuration and Helper Functions
# ============================================================================

# Configuration
Entrez.email = "your.email@example.com"  # Required for NCBI access
PROTEIN_IDS = ["P01308", "P01542"]  # P01308 = Insulin, P01542 = Crambin (1CRN)
PDB_IDS = ["1CRN"]  # PDB structures to analyze (can add more like ["1CRN", "3I40"])

# Helper function for HTML display
def create_html_section(title, content, color="#2c3e50"):
    """Create formatted HTML section"""
    return f"""
    <div style='margin: 20px 0; padding: 15px; border-left: 5px solid {color}; background-color: #f8f9fa;'>
        <h3 style='color: {color}; margin-top: 0;'>{title}</h3>
        {content}
    </div>
    """

print("‚úì Configuration complete!")

"""#**WHAT THIS CELL DOES:**
- Connects to UniProt database via REST API
- Downloads FASTA format sequences for each protein
- Parses sequences using Biopython's SeqIO module
- Stores protein records for downstream analysis

#**HOW IT WORKS:**
1. Constructs URL: https://rest.uniprot.org/uniprotkb/{ID}.fasta
2. Makes HTTP GET request to fetch the data
3. Parses FASTA format (header line with '>' followed by sequence)
4. Extracts sequence, description, and metadata

#**FASTA FORMAT:**
>sp|P01308|INS_HUMAN Insulin OS=Homo sapiens...
MALWMRLLPLLALLALWGPDPAAAFVNQHLCGSHLVEALYLVCGERGFFYTPKT...

#**WHY UNIPROT:**
UniProt is the most comprehensive protein sequence database, containing:
- Reviewed sequences (Swiss-Prot): manually annotated, high quality
- Unreviewed sequences (TrEMBL): automatically annotated
- Extensive cross-references to other databases
- Functional annotations and literature references
"""

# ============================================================================
# CELL 3: Protein Sequence Fetching from UniProt
# ============================================================================

def fetch_protein_from_uniprot(accession_id):
    """Fetch protein sequence from UniProt"""
    url = f"https://rest.uniprot.org/uniprotkb/{accession_id}.fasta"
    try:
        response = requests.get(url)
        if response.status_code == 200:
            fasta_data = io.StringIO(response.text)
            record = SeqIO.read(fasta_data, "fasta")
            return record
        else:
            print(f"‚úó Failed to fetch {accession_id}: Status {response.status_code}")
            return None
    except Exception as e:
        print(f"‚úó Error fetching {accession_id}: {str(e)}")
        return None

print("Fetching protein sequences from UniProt...")
protein_records = {}
for protein_id in PROTEIN_IDS:
    record = fetch_protein_from_uniprot(protein_id)
    if record:
        protein_records[protein_id] = record
        print(f"‚úì Fetched {protein_id}: {record.description[:60]}...")

print(f"\n‚úì Successfully fetched {len(protein_records)} protein sequences!")

"""#**WHAT THIS CELL DOES:**
- Creates formatted HTML tables with protein information
- Displays accession ID, description, length, and sequence preview
- Presents data in an easy-to-read, professional format

#**KEY INFORMATION DISPLAYED:**
1. Accession ID: Unique identifier in UniProt (e.g., P01308)
2. Description: Full protein name, organism, and database info
3. Sequence Length: Total number of amino acids in the protein
4. First 50 Residues: Preview of the N-terminus sequence

#**WHY FIRST 50 RESIDUES:**
- Shows the signal peptide and beginning of mature protein
- Enough to identify the protein by BLAST search
- Keeps display manageable (full sequences can be very long)

#**UNDERSTANDING THE DESCRIPTION:**
Example: "sp|P01308|INS_HUMAN Insulin OS=Homo sapiens OX=9606 GN=INS PE=1 SV=1"
- sp: Swiss-Prot (reviewed entry)
- P01308: Accession number
- INS_HUMAN: Entry name (gene_organism)
- OS: Organism species
- OX: NCBI Taxonomy ID
- GN: Gene name
- PE: Protein existence level (1 = experimental evidence)
- SV: Sequence version

#**HTML FORMATTING:**
The code uses inline CSS to create:
- Color-coded headers (blue background)
- Alternating row colors for readability
- Monospace font for sequences (easier to count residues)
- Responsive tables that look good on any screen
"""

# ============================================================================
# CELL 4: Display Protein Sequence Information
# ============================================================================

def display_protein_info(records):
    """Display protein information in HTML format"""
    html_content = "<div style='font-family: Arial, sans-serif;'>"

    for acc_id, record in records.items():
        seq_str = str(record.seq)
        preview = seq_str[:50] + "..." if len(seq_str) > 50 else seq_str

        info = f"""
        <table style='width: 100%; border-collapse: collapse; margin: 10px 0;'>
            <tr style='background-color: #3498db; color: white;'>
                <th style='padding: 10px; text-align: left;'>Property</th>
                <th style='padding: 10px; text-align: left;'>Value</th>
            </tr>
            <tr style='background-color: #ecf0f1;'>
                <td style='padding: 8px;'><strong>Accession ID</strong></td>
                <td style='padding: 8px;'>{acc_id}</td>
            </tr>
            <tr>
                <td style='padding: 8px;'><strong>Description</strong></td>
                <td style='padding: 8px;'>{record.description}</td>
            </tr>
            <tr style='background-color: #ecf0f1;'>
                <td style='padding: 8px;'><strong>Sequence Length</strong></td>
                <td style='padding: 8px;'>{len(seq_str)} amino acids</td>
            </tr>
            <tr>
                <td style='padding: 8px;'><strong>First 50 Residues</strong></td>
                <td style='padding: 8px; font-family: monospace; background-color: #f9f9f9;'>{preview}</td>
            </tr>
        </table>
        """
        html_content += create_html_section(f"Protein: {acc_id}", info, "#3498db")

    html_content += "</div>"
    return html_content

# Display protein information
display(HTML(display_protein_info(protein_records)))

"""#**Amino Acid Composition Analysis**

This section calculates the percentage of each amino acid in every protein sequence.

analyze_amino_acid_composition() counts amino acids and converts them into percentages.

The results help understand protein chemistry, like hydrophobicity and charge distribution.

plot_aa_composition() visualizes the composition as a bar chart for any selected protein.

Finally, the code automatically plots the composition of the first protein record.
"""

# ============================================================================
# CELL 5: Amino Acid Composition Analysis
# ============================================================================

def analyze_amino_acid_composition(records):
    """Analyze and return amino acid composition for all proteins"""
    compositions = {}

    for acc_id, record in records.items():
        seq_str = str(record.seq)
        aa_count = Counter(seq_str)
        total = len(seq_str)
        aa_percent = {aa: (count/total)*100 for aa, count in aa_count.items()}
        compositions[acc_id] = aa_percent

    return compositions

# Calculate compositions
aa_compositions = analyze_amino_acid_composition(protein_records)

# Visualize amino acid composition
def plot_aa_composition(compositions, protein_id):
    """Plot amino acid composition for a specific protein"""
    if protein_id not in compositions:
        print(f"Protein {protein_id} not found!")
        return

    comp = compositions[protein_id]
    aa_list = sorted(comp.keys())
    percentages = [comp[aa] for aa in aa_list]

    plt.figure(figsize=(14, 6))
    colors = plt.cm.viridis(np.linspace(0, 1, len(aa_list)))
    bars = plt.bar(aa_list, percentages, color=colors, edgecolor='black', linewidth=0.5)

    plt.xlabel('Amino Acid', fontsize=12, fontweight='bold')
    plt.ylabel('Percentage (%)', fontsize=12, fontweight='bold')
    plt.title(f'Amino Acid Composition - {protein_id}', fontsize=14, fontweight='bold')
    plt.xticks(rotation=0, ha='center')
    plt.grid(axis='y', alpha=0.3)

    # Add percentage labels on bars
    for bar in bars:
        height = bar.get_height()
        if height > 0.5:  # Only label if significant
            plt.text(bar.get_x() + bar.get_width()/2., height,
                    f'{height:.1f}%', ha='center', va='bottom', fontsize=8)

    plt.tight_layout()
    plt.show()

# Plot for first protein
if protein_records:
    first_protein = list(protein_records.keys())[0]
    print(f"Amino Acid Composition Analysis for {first_protein}:")
    plot_aa_composition(aa_compositions, first_protein)

"""#**Protein Sequence Length Comparison**

This cell compares the lengths of all protein sequences in the dataset.

plot_sequence_lengths() extracts each protein‚Äôs accession ID and sequence length.

A bar chart is generated to visually compare protein sizes.

The plot includes:

*  Unique colors for each protein

*  Length labels on top of each bar

*   Rotated x-axis labels for readability

Helps quickly identify shortest and longest proteins in the collection.
"""

# ============================================================================
# CELL 6: Protein Sequence Length Comparison
# ============================================================================

def plot_sequence_lengths(records):
    """Plot comparison of protein sequence lengths"""
    acc_ids = list(records.keys())
    lengths = [len(record.seq) for record in records.values()]

    plt.figure(figsize=(10, 6))
    colors = plt.cm.Set3(np.linspace(0, 1, len(acc_ids)))
    bars = plt.bar(acc_ids, lengths, color=colors, edgecolor='black', linewidth=1.5)

    plt.xlabel('Protein Accession ID', fontsize=12, fontweight='bold')
    plt.ylabel('Sequence Length (amino acids)', fontsize=12, fontweight='bold')
    plt.title('Protein Sequence Length Comparison', fontsize=14, fontweight='bold')
    plt.xticks(rotation=45, ha='right')
    plt.grid(axis='y', alpha=0.3)

    # Add value labels on bars
    for bar in bars:
        height = bar.get_height()
        plt.text(bar.get_x() + bar.get_width()/2., height,
                f'{int(height)}', ha='center', va='bottom', fontsize=10, fontweight='bold')

    plt.tight_layout()
    plt.show()

print("Protein Sequence Length Comparison:")
plot_sequence_lengths(protein_records)

"""#**PDB Structure Fetching & Chain Analysis**

This cell downloads multiple PDB structure files from the RCSB Protein Data Bank.

fetch_pdb_structure() retrieves each .pdb file using its PDB ID and saves it locally.

analyze_pdb_structure() uses Biopython‚Äôs PDBParser to:

*   Read the structure

*    Extract all chains

*   Count residues in each chain

For every PDB ID:

*   The file is downloaded

*  Parsed to identify chains (A, B, etc.)

*   Number of residues per chain is printed

Results are stored in:

pdb_structures ‚Üí full parsed structure objects

all_chain_residues ‚Üí residue count per chain

This step provides essential structural metadata before visualization, RMSD calculation, or motif mapping.
"""

# ============================================================================
# CELL 7: PDB Structure Fetching and Parsing (Multiple Structures)
# ============================================================================

def fetch_pdb_structure(pdb_id):
    """Fetch PDB structure file"""
    url = f"https://files.rcsb.org/download/{pdb_id}.pdb"
    try:
        response = requests.get(url)
        if response.status_code == 200:
            # Save to file
            filename = f"{pdb_id}.pdb"
            with open(filename, 'w') as f:
                f.write(response.text)
            print(f"‚úì Downloaded PDB structure: {pdb_id}")
            return filename
        else:
            print(f"‚úó Failed to download {pdb_id}: Status {response.status_code}")
            return None
    except Exception as e:
        print(f"‚úó Error downloading {pdb_id}: {str(e)}")
        return None

def analyze_pdb_structure(pdb_file):
    """Parse PDB structure and analyze chains"""
    parser = PDBParser(QUIET=True)
    structure = parser.get_structure("protein", pdb_file)

    chain_data = {}
    for model in structure:
        for chain in model:
            chain_id = chain.get_id()
            residues = list(chain.get_residues())
            chain_data[chain_id] = len(residues)

    return structure, chain_data

# Fetch and analyze all PDB structures
print(f"Fetching PDB structures: {PDB_IDS}")
pdb_structures = {}
all_chain_residues = {}

for pdb_id in PDB_IDS:
    print(f"\nProcessing PDB: {pdb_id}")
    pdb_file = fetch_pdb_structure(pdb_id)

    if pdb_file:
        structure, chain_residues = analyze_pdb_structure(pdb_file)
        pdb_structures[pdb_id] = {'file': pdb_file, 'structure': structure}
        all_chain_residues[pdb_id] = chain_residues

        print(f"‚úì PDB Structure Analysis for {pdb_id}:")
        print(f"  Chains found: {list(chain_residues.keys())}")
        for chain_id, res_count in chain_residues.items():
            print(f"  Chain {chain_id}: {res_count} residues")

"""#**PDB Chain Residue Visualization**

This cell visualizes how many residues each chain contains for every PDB structure.

plot_chain_residues():

*  Takes the chain‚Äìresidue dictionary for one PDB ID

*  Creates a bar graph showing residue counts for each chain

*  Uses soft Pastel colors + residue count labels on top

The loop plots chain‚Äìresidue distributions for all PDB IDs in all_chain_residues.

*  Helps quickly compare:

*  Chain lengths

*  Multi-chain vs single-chain structures

Structural asymmetry within proteins

This step provides easy structural overview before deeper analysis.
"""

# ============================================================================
# CELL 8: Visualize PDB Chain Residues (All Structures)
# ============================================================================

def plot_chain_residues(chain_data, pdb_id):
    """Plot residue count per chain"""
    if not chain_data:
        print("No chain data available!")
        return

    chains = list(chain_data.keys())
    residue_counts = list(chain_data.values())

    plt.figure(figsize=(10, 6))
    colors = plt.cm.Pastel1(np.linspace(0, 1, len(chains)))
    bars = plt.bar(chains, residue_counts, color=colors, edgecolor='black', linewidth=1.5)

    plt.xlabel('Chain ID', fontsize=12, fontweight='bold')
    plt.ylabel('Number of Residues', fontsize=12, fontweight='bold')
    plt.title(f'Residue Count per Chain - PDB: {pdb_id}', fontsize=14, fontweight='bold')
    plt.grid(axis='y', alpha=0.3)

    # Add value labels
    for bar in bars:
        height = bar.get_height()
        plt.text(bar.get_x() + bar.get_width()/2., height,
                f'{int(height)}', ha='center', va='bottom', fontsize=11, fontweight='bold')

    plt.tight_layout()
    plt.show()

# Plot chain residues for all PDB structures
if all_chain_residues:
    print("\nChain Residue Distribution:")
    for pdb_id, chain_data in all_chain_residues.items():
        print(f"\n{pdb_id}:")
        plot_chain_residues(chain_data, pdb_id)

"""#**3D Protein Structure Visualization**

This section generates interactive 3D visualizations for all downloaded PDB structures using the py3Dmol library. The function loads each PDB file and renders it in multiple molecular styles‚Äîsuch as cartoon, stick, sphere, and secondary-structure coloring‚Äîto provide different structural perspectives. The cartoon mode highlights overall folding and major secondary-structure elements, stick mode reveals atomic-level side-chain interactions, and sphere mode shows space-filling van der Waals surfaces. Coloring schemes like spectrum, chain, and secondary-structure enhance interpretability by emphasizing structural organization, residue progression, or chain separation. These interactive models allow users to rotate, zoom, and inspect 3D features, making structural interpretation clearer and more intuitive within the notebook environment.
"""

# ============================================================================
# CELL 8B: 3D Protein Structure Visualization (All Structures)
# ============================================================================

def visualize_protein_3d(pdb_id, pdb_file, style='cartoon', color_scheme='spectrum'):
    """
    Visualize protein structure in 3D using py3Dmol

    Parameters:
    - pdb_id: PDB identifier
    - pdb_file: Path to PDB file
    - style: 'cartoon', 'stick', 'sphere', 'line', 'cross'
    - color_scheme: 'spectrum', 'chain', 'ss' (secondary structure), 'residue'
    """
    # Create viewer
    view = py3Dmol.view(width=800, height=600)

    # Fetch structure from file
    view.addModel(open(pdb_file, 'r').read(), 'pdb')

    # Set style
    if style == 'cartoon':
        view.setStyle({style: {'color': color_scheme}})
    elif style == 'stick':
        view.setStyle({'stick': {'colorscheme': color_scheme}})
    elif style == 'sphere':
        view.setStyle({'sphere': {'colorscheme': color_scheme}})
    elif style == 'line':
        view.setStyle({'line': {'colorscheme': color_scheme}})
    else:
        view.setStyle({style: {'color': color_scheme}})

    # Center and zoom
    view.zoomTo()

    return view

# Visualize all PDB structures
if pdb_structures:
    print("\n" + "="*80)
    print("GENERATING 3D VISUALIZATIONS FOR ALL STRUCTURES")
    print("="*80)

    for pdb_id, data in pdb_structures.items():
        pdb_file = data['file']

        print(f"\n{'='*80}")
        print(f"3D VISUALIZATION: {pdb_id}")
        print(f"{'='*80}")

        # Style 1: Cartoon representation with spectrum coloring
        print(f"\nüé® Style 1: Cartoon Representation (Spectrum Coloring) - {pdb_id}")
        print("   - Shows secondary structure elements")
        print("   - Color gradient from N-terminus (blue) to C-terminus (red)")
        view1 = visualize_protein_3d(pdb_id, pdb_file, 'cartoon', 'spectrum')
        view1.show()

        print(f"\nüé® Style 2: Stick Representation (Atomic Detail) - {pdb_id}")
        print("   - Shows all atoms as sticks")
        print("   - Useful for seeing side chain interactions")
        view2 = visualize_protein_3d(pdb_id, pdb_file, 'stick', 'greenCarbon')
        view2.show()

        print(f"\nüé® Style 3: Sphere Representation (Space-Filling) - {pdb_id}")
        print("   - Van der Waals spheres")
        print("   - Shows protein volume and packing")
        view3 = visualize_protein_3d(pdb_id, pdb_file, 'sphere', 'chain')
        view3.show()

        print(f"\nüé® Style 4: Cartoon + Secondary Structure Coloring - {pdb_id}")
        print("   - Helices in magenta, sheets in yellow")
        print("   - Clearly shows protein architecture")
        view4 = visualize_protein_3d(pdb_id, pdb_file, 'cartoon', 'ss')
        view4.show()

    print("\n‚úì All 3D visualizations generated successfully!")
    print("  üí° TIP: You can rotate, zoom, and interact with the structures above")
else:
    print("‚úó No PDB structures available for 3D visualization")

"""#**Protein Motif Analysis**

This section performs a straightforward protein motif analysis by scanning each sequence for a specific amino acid pattern, such as the ‚ÄúGG‚Äù (glycine-glycine) motif used here. For every protein, the code counts how many times the motif appears and records the first few positions where it occurs. These results help reveal patterns of motif enrichment or scarcity across proteins. To make the findings easier to interpret, a bar chart is generated showing motif frequencies for each protein, allowing quick visual comparison of how often the selected motif is present within different sequences.
"""

# ============================================================================
# CELL 9: Protein Motif Analysis
# ============================================================================

def analyze_protein_motifs(records, motif_pattern="TATA"):
    """Simple motif analysis - search for pattern in sequences"""
    motif_results = {}

    for acc_id, record in records.items():
        seq_str = str(record.seq)
        positions = []
        start = 0
        while True:
            pos = seq_str.find(motif_pattern, start)
            if pos == -1:
                break
            positions.append(pos)
            start = pos + 1

        motif_results[acc_id] = {
            'count': len(positions),
            'positions': positions[:10]  # First 10 occurrences
        }

    return motif_results

# Analyze motifs
print("Analyzing protein motifs...")
motif_pattern = "GG"  # Looking for glycine-glycine motif
motif_results = analyze_protein_motifs(protein_records, motif_pattern)

print(f"\nMotif Analysis Results (Pattern: {motif_pattern}):")
for acc_id, result in motif_results.items():
    print(f"  {acc_id}: Found {result['count']} occurrences")
    if result['positions']:
        print(f"    First positions: {result['positions']}")

# Visualize motif frequency
def plot_motif_frequency(motif_results, pattern):
    """Plot motif frequency across proteins"""
    acc_ids = list(motif_results.keys())
    counts = [result['count'] for result in motif_results.values()]

    plt.figure(figsize=(10, 6))
    colors = plt.cm.Set2(np.linspace(0, 1, len(acc_ids)))
    bars = plt.bar(acc_ids, counts, color=colors, edgecolor='black', linewidth=1.5)

    plt.xlabel('Protein Accession ID', fontsize=12, fontweight='bold')
    plt.ylabel('Motif Occurrences', fontsize=12, fontweight='bold')
    plt.title(f'Motif Frequency Analysis - Pattern: "{pattern}"', fontsize=14, fontweight='bold')
    plt.xticks(rotation=45, ha='right')
    plt.grid(axis='y', alpha=0.3)

    # Add value labels
    for bar in bars:
        height = bar.get_height()
        plt.text(bar.get_x() + bar.get_width()/2., height,
                f'{int(height)}', ha='center', va='bottom', fontsize=10, fontweight='bold')

    plt.tight_layout()
    plt.show()

print(f"\nMotif Frequency Visualization:")
plot_motif_frequency(motif_results, motif_pattern)

"""#**Note on Phylogenetic Tree Code**

This block of code creates and visualizes a simple phylogenetic tree from the protein sequences you collected. Steps:

Sequence Preparation
*  Takes sequences from records
* Uses the first 100 amino acids of each
*  Pads them with ‚Äú‚Äì‚Äù so all sequences have equal length

Multiple Sequence Alignment (MSA)
*  Constructs a basic alignment using MultipleSeqAlignment
* No external alignment tool (Clustal, MUSCLE) ‚Äî a simple, quick method

Distance Matrix Calculation
‚Äì Uses identity scoring to compute pairwise distances

Tree Construction
‚Äì Builds a phylogenetic tree using UPGMA (hierarchical clustering)

Tree Visualization
*  Plots the tree using Phylo.draw() from Biopython
*  Adds title and formatting for readability
"""

# ============================================================================
# CELL 10: Phylogenetic Tree Construction
# ============================================================================

def create_phylogenetic_tree(records):
    """Create simple phylogenetic tree from protein sequences"""
    if len(records) < 2:
        print("Need at least 2 sequences for phylogenetic analysis!")
        return None

    # Create alignment (simple approach - just use sequences as-is)
    seq_records = []
    for acc_id, record in records.items():
        # Truncate/pad sequences to same length for simple alignment
        seq = str(record.seq)[:100]  # Use first 100 amino acids
        seq_record = SeqRecord(Seq(seq), id=acc_id, description="")
        seq_records.append(seq_record)

    # Pad sequences to same length
    max_len = max(len(r.seq) for r in seq_records)
    for record in seq_records:
        if len(record.seq) < max_len:
            record.seq = Seq(str(record.seq) + '-' * (max_len - len(record.seq)))

    # Create alignment
    alignment = MultipleSeqAlignment(seq_records)

    # Calculate distance matrix
    calculator = DistanceCalculator('identity')
    dm = calculator.get_distance(alignment)

    # Construct tree
    constructor = DistanceTreeConstructor(calculator)
    tree = constructor.upgma(dm)

    return tree

print("Creating phylogenetic tree...")
if len(protein_records) >= 2:
    phylo_tree = create_phylogenetic_tree(protein_records)

    if phylo_tree:
        # Visualize tree
        plt.figure(figsize=(12, 8))
        Phylo.draw(phylo_tree, do_show=False)
        plt.title('Protein Phylogenetic Tree (UPGMA)', fontsize=14, fontweight='bold')
        plt.tight_layout()
        plt.show()
        print("‚úì Phylogenetic tree created successfully!")
else:
    print("‚úó Need at least 2 protein sequences for phylogenetic analysis")

"""#**Short Note on the HTML Dashboard Code**

The provided Python function creates a complete HTML-based bioinformatics dashboard that summarizes all analysis results for proteins (e.g., P01308 Insulin) and structures (e.g., PDB 1CRN Crambin). It includes:

Header Section
‚Äì Title and description of the analysis.

Summary Statistics
‚Äì Total proteins analyzed
‚Äì Average sequence length
‚Äì Total amino acid residues

Protein Details
‚Äì Accession ID
‚Äì Description
‚Äì Sequence length
‚Äì Top 3 most abundant amino acids
‚Äì Sequence preview (first 100 residues)

Motif Analysis Section
‚Äì Shows motif counts for each protein

PDB Structure Analysis
‚Äì Number of chains
‚Äì Residue count per chain for each structure (e.g., 1CRN)

Styled UI Components
‚Äì Modern cards, gradients, shadows, monospace sequence boxes, grid layout

Footer
‚Äì Marks completion of protein + PDB comparative analysis
"""

# ============================================================================
# CELL 11: Comprehensive HTML Dashboard
# ============================================================================

def create_comprehensive_dashboard(records, compositions, motif_results, all_chain_data, pdb_ids):
    """Create comprehensive HTML dashboard with all results"""

    # Header
    html = """
    <div style='font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px;'>
        <div style='background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white; padding: 30px; border-radius: 10px; margin-bottom: 30px;'>
            <h1 style='margin: 0; font-size: 36px;'>üß¨ Protein Bioinformatics Analysis Dashboard</h1>
            <p style='margin: 10px 0 0 0; font-size: 18px;'>P01308 (Insulin) & 1CRN (Crambin) - Complete Analysis</p>
        </div>
    """

    # Summary Statistics
    total_proteins = len(records)
    avg_length = int(np.mean([len(r.seq) for r in records.values()]))
    total_residues = sum(len(r.seq) for r in records.values())

    summary = f"""
    <div style='display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-bottom: 30px;'>
        <div style='background: #3498db; color: white; padding: 20px; border-radius: 10px; text-align: center;'>
            <h2 style='margin: 0; font-size: 40px;'>{total_proteins}</h2>
            <p style='margin: 10px 0 0 0;'>Proteins Analyzed</p>
        </div>
        <div style='background: #2ecc71; color: white; padding: 20px; border-radius: 10px; text-align: center;'>
            <h2 style='margin: 0; font-size: 40px;'>{avg_length}</h2>
            <p style='margin: 10px 0 0 0;'>Avg. Sequence Length</p>
        </div>
        <div style='background: #e74c3c; color: white; padding: 20px; border-radius: 10px; text-align: center;'>
            <h2 style='margin: 0; font-size: 40px;'>{total_residues}</h2>
            <p style='margin: 10px 0 0 0;'>Total Residues</p>
        </div>
    </div>
    """
    html += summary

    # Protein Details
    html += "<h2 style='color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px;'>üìä Protein Details</h2>"

    for acc_id, record in records.items():
        seq_str = str(record.seq)
        comp = compositions.get(acc_id, {})
        top_aa = sorted(comp.items(), key=lambda x: x[1], reverse=True)[:3]

        details = f"""
        <div style='background: white; border: 2px solid #ecf0f1; border-radius: 10px;
                    padding: 20px; margin: 20px 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1);'>
            <h3 style='color: #3498db; margin-top: 0;'>üß¨ {acc_id}</h3>
            <p><strong>Description:</strong> {record.description}</p>
            <p><strong>Length:</strong> {len(seq_str)} amino acids</p>
            <p><strong>Top 3 Amino Acids:</strong>
                {', '.join([f"{aa} ({pct:.1f}%)" for aa, pct in top_aa])}</p>
            <p><strong>Sequence Preview:</strong></p>
            <div style='background: #f8f9fa; padding: 15px; border-radius: 5px;
                        font-family: monospace; font-size: 12px; overflow-x: auto;'>
                {seq_str[:100]}{'...' if len(seq_str) > 100 else ''}
            </div>
        </div>
        """
        html += details

    # Motif Analysis Section
    html += "<h2 style='color: #2c3e50; border-bottom: 3px solid #e74c3c; padding-bottom: 10px; margin-top: 40px;'>üîç Motif Analysis</h2>"

    motif_html = "<div style='background: white; border: 2px solid #ecf0f1; border-radius: 10px; padding: 20px; margin: 20px 0;'>"
    for acc_id, result in motif_results.items():
        motif_html += f"<p><strong>{acc_id}:</strong> {result['count']} occurrences</p>"
    motif_html += "</div>"
    html += motif_html

    # PDB Structure Section
    if all_chain_data:
        html += "<h2 style='color: #2c3e50; border-bottom: 3px solid #2ecc71; padding-bottom: 10px; margin-top: 40px;'>üèóÔ∏è PDB Structure Analysis</h2>"

        for pdb_id, chain_data in all_chain_data.items():
            pdb_html = f"""
            <div style='background: white; border: 2px solid #ecf0f1; border-radius: 10px;
                        padding: 20px; margin: 20px 0;'>
                <h3 style='color: #2ecc71; margin-top: 0;'>Structure: {pdb_id}</h3>
                <p><strong>Number of Chains:</strong> {len(chain_data)}</p>
            """
            for chain_id, res_count in chain_data.items():
                pdb_html += f"<p><strong>Chain {chain_id}:</strong> {res_count} residues</p>"
            pdb_html += "</div>"
            html += pdb_html

    # Footer
    html += """
        <div style='background: #34495e; color: white; padding: 20px;
                    border-radius: 10px; margin-top: 40px; text-align: center;'>
            <p style='margin: 0;'>‚ú® Analysis Complete - P01308 & 1CRN Comparison ‚ú®</p>
            <p style='margin: 10px 0 0 0; font-size: 12px; opacity: 0.8;'>
                Generated using Biopython and Python visualization libraries
            </p>
        </div>
    </div>
    """

    return html

# Generate and display dashboard
print("\nGenerating Comprehensive HTML Dashboard...")
dashboard_html = create_comprehensive_dashboard(
    protein_records,
    aa_compositions,
    motif_results,
    all_chain_residues,
    PDB_IDS
)

display(HTML(dashboard_html))
print("\n" + "="*80)
print("‚úì PIPELINE COMPLETE! All analyses finished successfully.")
print("="*80)

